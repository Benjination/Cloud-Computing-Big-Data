<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Search & Analysis - Quiz Project</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .container { background: #f9f9f9; padding: 20px; border-radius: 8px; margin: 20px 0; }
        button { background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #45a049; }
        input, select { padding: 8px; margin: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .search-row { display: flex; align-items: center; gap: 10px; margin: 10px 0; flex-wrap: wrap; }
        .results { margin: 20px 0; }
        .record { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #4CAF50; }
        .pagination { display: flex; justify-content: center; gap: 10px; margin: 20px 0; }
        .analysis { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .config-warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .status { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .export-section { background: #f0f8ff; padding: 15px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Data Analysis Project - Search & Analysis</h1>
    

    <div class="container">
        <h2>Search Controls</h2>
        
        <!-- Dynamic Field Search - CUSTOMIZE FOR YOUR DATA -->
        <div class="search-row">
            <label>Field:</label>
            <select id="searchField">
                <option value="">Select field...</option>
                <!-- Will be populated dynamically -->
            </select>
            <label>Value:</label>
            <input type="text" id="searchValue" placeholder="Enter search value">
            <label>Operator:</label>
            <select id="searchOperator">
                <option value="==">=</option>
                <option value="!=">‚â†</option>
                <option value=">">&gt;</option>
                <option value="<">&lt;</option>
                <option value=">=">&gt;=</option>
                <option value="<=">&lt;=</option>
                <option value="contains">Contains</option>
                <option value="starts">Starts with</option>
            </select>
            <button onclick="searchData()">Search</button>
        </div>
        
        <!-- Range Search for Numeric Fields -->
        <div class="search-row">
            <label>Numeric Range:</label>
            <select id="rangeField">
                <option value="">Select numeric field...</option>
            </select>
            <input type="number" id="minValue" placeholder="Min" step="any">
            <input type="number" id="maxValue" placeholder="Max" step="any">
            <button onclick="rangeSearch()">Range Search</button>
        </div>
        
        <!-- Quick Actions -->
        <div class="search-row">
            <button onclick="getAllData()">Show All Data</button>
            <button onclick="clearResults()">Clear Results</button>
            <button onclick="analyzeData()">Generate Analysis</button>
            <button onclick="exportResults()">Export Results</button>
        </div>
    </div>

    <!-- üåç EARTHQUAKE-SPECIFIC SEARCH CONTROLS -->
    <div class="container">
        <h2>üåç Earthquake-Specific Searches</h2>
        
        <!-- Quick Earthquake Searches -->
        <div class="search-row">
            <button onclick="quickMagnitudeSearch()" style="background: #e74c3c;">
                üîç Quick Magnitude Search
            </button>
            <button onclick="quickMagnitudeRangeSearch()" style="background: #e67e22;">
                üìä Magnitude Range Search
            </button>
            <button onclick="quickNetworkSearch()" style="background: #9b59b6;">
                üåê Network Search
            </button>
        </div>

        <!-- Common Magnitude Ranges -->
        <div class="search-row">
            <label>Common Magnitude Ranges:</label>
            <button onclick="searchMagnitudeRange(1.0, 3.0)" style="background: #27ae60;">
                Minor (1.0-3.0)
            </button>
            <button onclick="searchMagnitudeRange(3.0, 5.0)" style="background: #f39c12;">
                Moderate (3.0-5.0)
            </button>
            <button onclick="searchMagnitudeRange(5.0, 7.0)" style="background: #e74c3c;">
                Major (5.0-7.0)
            </button>
            <button onclick="searchMagnitudeRange(7.0, 10.0)" style="background: #8e44ad;">
                Great (7.0+)
            </button>
        </div>

        <!-- Common Networks -->
        <div class="search-row">
            <label>Common Networks:</label>
            <button onclick="searchByNetwork('us')" style="background: #3498db;">
                US Geological Survey
            </button>
            <button onclick="searchByNetwork('ci')" style="background: #2ecc71;">
                California
            </button>
            <button onclick="searchByNetwork('nc')" style="background: #e67e22;">
                Northern California
            </button>
            <button onclick="searchByNetwork('ak')" style="background: #9b59b6;">
                Alaska
            </button>
        </div>
    </div>

    <!-- üìà PERFORMANCE ANALYTICS DASHBOARD -->
    <div class="container">
        <h2>üìà Earthquake Search Performance Analytics</h2>
        <div class="search-row">
            <button onclick="exportEarthquakePerformanceData()" style="background: #28a745;">
                üìä Export Performance CSV
            </button>
            <button onclick="showEarthquakeCacheStatus()" style="background: #17a2b8;">
                üìã View Cache Status
            </button>
            <button onclick="clearEarthquakeCache()" style="background: #ffc107; color: #333;">
                üßπ Clear Cache
            </button>
            <button onclick="testCache()" style="background: #6c757d;">
                üß™ Test Cache System
            </button>
        </div>
        <p><small>
            Performance analytics track search times and cache effectiveness. 
            First-time searches hit Firebase; repeat searches use cache for instant results.
        </small></p>
    </div>

    <div class="container">
        <h2>Results</h2>
        <div id="resultsCount"></div>
        <div id="results"></div>
        <div id="pagination" class="pagination"></div>
    </div>

    <div class="container">
        <h2>Data Analysis</h2>
        <div id="analysis"></div>
    </div>

    <div class="export-section">
        <h3>Export Options</h3>
        <button onclick="downloadCSV()">Download as CSV</button>
        <button onclick="downloadJSON()">Download as JSON</button>
        <textarea id="exportData" style="width: 100%; height: 100px; margin: 10px 0;" placeholder="Export data will appear here"></textarea>
    </div>

    <div class="container">
        <h2>Navigation</h2>
        <button onclick="window.location.href='firebase-index.html'">Back to Upload</button>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // üî• FIREBASE CONFIGURATION FOR PROJECT: realquiz2-a1d06
        const firebaseConfig = {
            apiKey: "AIzaSyARxVQ5jA7HZoYKZUSyxDsuHh9-b6pidWQ",
            authDomain: "realquiz2-a1d06.firebaseapp.com",
            projectId: "realquiz2-a1d06",
            storageBucket: "realquiz2-a1d06.firebasestorage.app",
            messagingSenderId: "1020294472984",
            appId: "1:1020294472984:web:3aee76d6a34be40d47ea6d",
            measurementId: "G-6NBBPMXKXL"
        };

        // Config is now properly set
        console.log("‚úÖ Firebase configuration loaded for project:", firebaseConfig.projectId);

        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.1.0/firebase-app.js';
        import { getFirestore, collection, query, where, orderBy, limit, getDocs, doc, getDoc, addDoc } from 'https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js';

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Global variables
        window.db = db;
        window.collection = collection;
        window.query = query;
        window.where = where;
        window.orderBy = orderBy;
        window.limit = limit;
        window.getDocs = getDocs;
        window.currentResults = [];
        window.currentPage = 1;
        window.pageSize = 20;
        window.COLLECTION_NAME = "quiz_data"; // CHANGE THIS FOR YOUR COLLECTION

        let availableFields = [];
        let numericFields = [];

        // üöÄ EARTHQUAKE DATA CACHE SYSTEM
        window.earthquakeCache = {
            magnitudeRange: new Map(),        // Key: "min-max", Value: {results, timestamp}
            magnitudeGreater: new Map(),      // Key: magnitude, Value: {results, timestamp}
            locationSearch: new Map(),        // Key: "lat,long,radius", Value: {results, timestamp}
            timeFilters: new Map(),           // Key: time range, Value: {results, timestamp}
            networkFilters: new Map(),        // Key: network code, Value: {results, timestamp}
            fieldSearches: new Map(),         // Key: "field_operator_value", Value: {results, timestamp}
            rangeSearches: new Map()          // Key: "field_min_max", Value: {results, timestamp}
        };

        // Cache expiration time (5 minutes)
        const CACHE_EXPIRY_MS = 5 * 60 * 1000;

        // Helper function to check if cache entry is still valid
        function isCacheValid(cacheEntry) {
            return cacheEntry && (Date.now() - cacheEntry.timestamp) < CACHE_EXPIRY_MS;
        }

        // Performance logging for earthquake search performance (with error handling)
        window.logEarthquakePerformance = async function(functionName, executionTime, resultCount = 0, additionalData = {}) {
            try {
                console.log(`üìä Performance: ${functionName} - ${executionTime.toFixed(3)}ms - ${resultCount} results`);
                
                const performanceData = {
                    function_name: functionName,
                    execution_time_ms: executionTime,
                    execution_time_s: executionTime / 1000,
                    result_count: resultCount,
                    timestamp: new Date(),
                    data_type: 'earthquake',
                    browser: navigator.userAgent.substring(0, 100),
                    ...additionalData
                };
                
                // Try to log to Firebase, but don't fail if it doesn't work
                await addDoc(collection(db, "earthquake_performance_logs"), performanceData);
                console.log(`‚úÖ Performance logged to Firebase`);
            } catch (error) {
                console.warn("Failed to log performance to Firebase (continuing anyway):", error);
                // Still log to console even if Firebase fails
                console.log(`üìä Performance: ${functionName} - ${executionTime.toFixed(3)}ms - ${resultCount} results (Firebase logging failed)`);
            }
        };

        // Initialize page
        async function initializePage() {
            try {
                await loadFields();
                await getAllData();
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('results').innerHTML = '<div class="status error">Failed to initialize. Check Firebase configuration.</div>';
            }
        }

        // Load available fields from data
        async function loadFields() {
            try {
                const snapshot = await getDocs(query(collection(db, window.COLLECTION_NAME), limit(1)));
                if (!snapshot.empty) {
                    const sampleDoc = snapshot.docs[0].data();
                    availableFields = Object.keys(sampleDoc);
                    
                    // Identify numeric fields
                    numericFields = availableFields.filter(field => {
                        const value = sampleDoc[field];
                        return typeof value === 'number';
                    });
                    
                    populateFieldSelectors();
                }
            } catch (error) {
                console.error('Error loading fields:', error);
            }
        }

        function populateFieldSelectors() {
            const searchField = document.getElementById('searchField');
            const rangeField = document.getElementById('rangeField');
            
            searchField.innerHTML = '<option value="">Select field...</option>';
            rangeField.innerHTML = '<option value="">Select numeric field...</option>';
            
            availableFields.forEach(field => {
                const option = new Option(field, field);
                searchField.appendChild(option);
            });
            
            numericFields.forEach(field => {
                const option = new Option(field, field);
                rangeField.appendChild(option);
            });
        }

        // Search functions with caching
        window.searchData = async function() {
            const startTime = performance.now();
            const field = document.getElementById('searchField').value;
            const value = document.getElementById('searchValue').value;
            const operator = document.getElementById('searchOperator').value;
            
            if (!field || !value) {
                alert('Please select a field and enter a value');
                return;
            }
            
            // Create cache key for this search
            const cacheKey = `${field}_${operator}_${value}`;
            
            // 1. Check cache first
            if (window.earthquakeCache.fieldSearches.has(cacheKey)) {
                const cacheEntry = window.earthquakeCache.fieldSearches.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached field search results');
                    const executionTime = performance.now() - startTime;
                    
                    // Display cached results
                    window.currentResults = cacheEntry.results;
                    window.currentPage = 1;
                    displayResults();
                    
                    // Log cached performance
                    await logEarthquakePerformance('field_search_cached', executionTime, cacheEntry.results.length, {
                        field: field,
                        operator: operator,
                        value: value,
                        cache_hit: true
                    });
                    return;
                }
            }
            
            try {
                let searchValue = value;
                
                // Convert value based on field type
                if (numericFields.includes(field)) {
                    searchValue = parseFloat(value);
                    if (isNaN(searchValue)) {
                        alert('Please enter a numeric value for this field');
                        return;
                    }
                }
                
                let q;
                if (operator === 'contains') {
                    // Firestore doesn't support contains, so we'll filter client-side
                    q = query(collection(db, window.COLLECTION_NAME));
                } else if (operator === 'starts') {
                    q = query(collection(db, window.COLLECTION_NAME), where(field, '>=', searchValue), where(field, '<', searchValue + '\uf8ff'));
                } else {
                    q = query(collection(db, window.COLLECTION_NAME), where(field, operator, searchValue));
                }
                
                const snapshot = await getDocs(q);
                let results = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Client-side filtering for 'contains'
                if (operator === 'contains') {
                    results = results.filter(item => 
                        item[field] && item[field].toString().toLowerCase().includes(value.toLowerCase())
                    );
                }
                
                // 2. Cache the results
                window.earthquakeCache.fieldSearches.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });
                
                const executionTime = performance.now() - startTime;
                
                // Log fresh performance
                await logEarthquakePerformance('field_search', executionTime, results.length, {
                    field: field,
                    operator: operator,
                    value: value,
                    cache_hit: false,
                    firebase_reads: snapshot.size
                });
                
                window.currentResults = results;
                window.currentPage = 1;
                displayResults();
                
            } catch (error) {
                console.error('Search error:', error);
                document.getElementById('results').innerHTML = `<div class="status error">Search failed: ${error.message}</div>`;
            }
        };

        window.rangeSearch = async function() {
            const startTime = performance.now();
            const field = document.getElementById('rangeField').value;
            const minValue = parseFloat(document.getElementById('minValue').value);
            const maxValue = parseFloat(document.getElementById('maxValue').value);
            
            if (!field || isNaN(minValue) || isNaN(maxValue)) {
                alert('Please select a numeric field and enter valid min/max values');
                return;
            }
            
            // Create cache key for this range search
            const cacheKey = `${field}_${minValue}_${maxValue}`;
            
            // 1. Check cache first
            if (window.earthquakeCache.rangeSearches.has(cacheKey)) {
                const cacheEntry = window.earthquakeCache.rangeSearches.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached range search results');
                    const executionTime = performance.now() - startTime;
                    
                    // Display cached results
                    window.currentResults = cacheEntry.results;
                    window.currentPage = 1;
                    displayResults();
                    
                    // Log cached performance
                    await logEarthquakePerformance('range_search_cached', executionTime, cacheEntry.results.length, {
                        field: field,
                        min_value: minValue,
                        max_value: maxValue,
                        cache_hit: true
                    });
                    return;
                }
            }
            
            try {
                const q = query(
                    collection(db, window.COLLECTION_NAME),
                    where(field, '>=', minValue),
                    where(field, '<=', maxValue)
                );
                
                const snapshot = await getDocs(q);
                const results = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 2. Cache the results
                window.earthquakeCache.rangeSearches.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });
                
                const executionTime = performance.now() - startTime;
                
                // Log fresh performance
                await logEarthquakePerformance('range_search', executionTime, results.length, {
                    field: field,
                    min_value: minValue,
                    max_value: maxValue,
                    cache_hit: false,
                    firebase_reads: snapshot.size
                });
                
                window.currentResults = results;
                window.currentPage = 1;
                displayResults();
                
            } catch (error) {
                console.error('Range search error:', error);
                document.getElementById('results').innerHTML = `<div class="status error">Range search failed: ${error.message}</div>`;
            }
        };

        window.getAllData = async function() {
            try {
                const snapshot = await getDocs(collection(db, window.COLLECTION_NAME));
                window.currentResults = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                window.currentPage = 1;
                displayResults();
            } catch (error) {
                console.error('Error getting all data:', error);
                document.getElementById('results').innerHTML = `<div class="status error">Failed to load data: ${error.message}</div>`;
            }
        };

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            const countDiv = document.getElementById('resultsCount');
            const paginationDiv = document.getElementById('pagination');
            
            if (!window.currentResults || window.currentResults.length === 0) {
                resultsDiv.innerHTML = '<div class="status">No results found</div>';
                countDiv.innerHTML = '';
                paginationDiv.innerHTML = '';
                return;
            }
            
            const totalResults = window.currentResults.length;
            const startIndex = (window.currentPage - 1) * window.pageSize;
            const endIndex = Math.min(startIndex + window.pageSize, totalResults);
            const pageResults = window.currentResults.slice(startIndex, endIndex);
            
            countDiv.innerHTML = `Showing ${startIndex + 1}-${endIndex} of ${totalResults} results`;
            
            let html = '';
            pageResults.forEach(record => {
                html += '<div class="record">';
                Object.entries(record).forEach(([key, value]) => {
                    if (key !== 'id') {
                        let displayValue = value;
                        if (value instanceof Date) {
                            displayValue = value.toLocaleDateString();
                        } else if (typeof value === 'number') {
                            displayValue = value.toLocaleString();
                        }
                        html += `<strong>${key}:</strong> ${displayValue}<br>`;
                    }
                });
                html += '</div>';
            });
            
            resultsDiv.innerHTML = html;
            
            // Pagination
            const totalPages = Math.ceil(totalResults / window.pageSize);
            let paginationHtml = '';
            
            if (window.currentPage > 1) {
                paginationHtml += `<button onclick="changePage(${window.currentPage - 1})">Previous</button>`;
            }
            
            for (let i = Math.max(1, window.currentPage - 2); i <= Math.min(totalPages, window.currentPage + 2); i++) {
                if (i === window.currentPage) {
                    paginationHtml += `<button style="background: #333;">${i}</button>`;
                } else {
                    paginationHtml += `<button onclick="changePage(${i})">${i}</button>`;
                }
            }
            
            if (window.currentPage < totalPages) {
                paginationHtml += `<button onclick="changePage(${window.currentPage + 1})">Next</button>`;
            }
            
            paginationDiv.innerHTML = paginationHtml;
        }

        window.changePage = function(page) {
            window.currentPage = page;
            displayResults();
        };

        window.clearResults = function() {
            window.currentResults = [];
            document.getElementById('results').innerHTML = '';
            document.getElementById('resultsCount').innerHTML = '';
            document.getElementById('pagination').innerHTML = '';
            document.getElementById('analysis').innerHTML = '';
        };

        // Analysis functions - CUSTOMIZE FOR YOUR DATA
        window.analyzeData = function() {
            if (!window.currentResults || window.currentResults.length === 0) {
                document.getElementById('analysis').innerHTML = '<div class="status error">No data to analyze</div>';
                return;
            }
            
            const data = window.currentResults;
            const analysisDiv = document.getElementById('analysis');
            
            let analysisHtml = '<div class="analysis">';
            analysisHtml += `<h3>Data Analysis (${data.length} records)</h3>`;
            
            // Basic statistics
            analysisHtml += `<p><strong>Total Records:</strong> ${data.length}</p>`;
            
            // Analyze numeric fields
            numericFields.forEach(field => {
                const values = data.map(item => item[field]).filter(v => v !== null && v !== undefined && !isNaN(v));
                if (values.length > 0) {
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const avg = values.reduce((a, b) => a + b, 0) / values.length;
                    
                    analysisHtml += `<div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px;">`;
                    analysisHtml += `<strong>${field}:</strong><br>`;
                    analysisHtml += `Min: ${min.toLocaleString()}, Max: ${max.toLocaleString()}, Average: ${avg.toFixed(2)}<br>`;
                    analysisHtml += `Total values: ${values.length}`;
                    analysisHtml += `</div>`;
                }
            });
            
            // Analyze categorical fields
            const categoricalFields = availableFields.filter(field => !numericFields.includes(field) && field !== 'id');
            categoricalFields.forEach(field => {
                const values = data.map(item => item[field]).filter(v => v !== null && v !== undefined);
                if (values.length > 0) {
                    const unique = [...new Set(values)];
                    if (unique.length <= 10) { // Only show for fields with reasonable number of categories
                        const counts = {};
                        values.forEach(v => counts[v] = (counts[v] || 0) + 1);
                        
                        analysisHtml += `<div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px;">`;
                        analysisHtml += `<strong>${field} Distribution:</strong><br>`;
                        Object.entries(counts)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 5)
                            .forEach(([value, count]) => {
                                analysisHtml += `${value}: ${count} (${(count/values.length*100).toFixed(1)}%)<br>`;
                            });
                        if (unique.length > 5) {
                            analysisHtml += `... and ${unique.length - 5} more categories`;
                        }
                        analysisHtml += `</div>`;
                    }
                }
            });
            
            analysisHtml += '</div>';
            analysisDiv.innerHTML = analysisHtml;
        };

        // Export functions
        window.exportResults = function() {
            if (!window.currentResults || window.currentResults.length === 0) {
                alert('No data to export');
                return;
            }
            
            const jsonData = JSON.stringify(window.currentResults, null, 2);
            document.getElementById('exportData').value = jsonData;
        };

        window.downloadCSV = function() {
            if (!window.currentResults || window.currentResults.length === 0) {
                alert('No data to export');
                return;
            }
            
            const headers = availableFields.filter(field => field !== 'id');
            let csv = headers.join(',') + '\n';
            
            window.currentResults.forEach(record => {
                const row = headers.map(header => {
                    let value = record[header] || '';
                    if (value instanceof Date) {
                        value = value.toISOString();
                    }
                    return `"${value.toString().replace(/"/g, '""')}"`;
                }).join(',');
                csv += row + '\n';
            });
            
            downloadFile(csv, 'quiz_data.csv', 'text/csv');
        };

        window.downloadJSON = function() {
            if (!window.currentResults || window.currentResults.length === 0) {
                alert('No data to export');
                return;
            }
            
            const jsonData = JSON.stringify(window.currentResults, null, 2);
            downloadFile(jsonData, 'quiz_data.json', 'application/json');
        };

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // üåç EARTHQUAKE-SPECIFIC SEARCH FUNCTIONS WITH CACHING

        // Enhanced Magnitude Range Search
        window.searchMagnitudeRange = async function(minMag, maxMag) {
            console.log(`üöÄ searchMagnitudeRange called: ${minMag} - ${maxMag}`);
            const startTime = performance.now();
            const cacheKey = `${minMag}-${maxMag}`;
            
            // 1. Check cache first
            console.log(`üîç Checking cache for key: ${cacheKey}`);
            if (window.earthquakeCache.magnitudeRange.has(cacheKey)) {
                const cacheEntry = window.earthquakeCache.magnitudeRange.get(cacheKey);
                console.log(`üì¶ Cache entry found, checking validity...`);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached magnitude range results');
                    const executionTime = performance.now() - startTime;
                    
                    // Display cached results
                    window.currentResults = cacheEntry.results;
                    window.currentPage = 1;
                    displayResults();
                    
                    // Log cached performance
                    await logEarthquakePerformance('magnitude_range_cached', executionTime, cacheEntry.results.length, {
                        min_magnitude: minMag,
                        max_magnitude: maxMag,
                        cache_hit: true
                    });
                    return cacheEntry.results;
                } else {
                    console.log('‚ùå Cache entry expired');
                }
            } else {
                console.log('‚ùå No cache entry found');
            }
            
            // 2. Query Firebase (first time)
            try {
                console.log(`üîç Searching for magnitude ${minMag} - ${maxMag} from Firebase`);
                const q = query(
                    collection(db, window.COLLECTION_NAME),
                    limit(2000) // reasonable limit for earthquake data
                );
                const snapshot = await getDocs(q);
                console.log(`üìä Retrieved ${snapshot.size} documents from Firebase`);
                
                // Client-side filtering for magnitude range
                const results = [];
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const mag = parseFloat(data.mag);
                    
                    if (!isNaN(mag) && mag >= minMag && mag <= maxMag) {
                        results.push({
                            id: docSnap.id,
                            time: data.time,
                            lat: parseFloat(data.lat) || 0,
                            long: parseFloat(data.long) || 0,
                            mag: mag,
                            net: data.net || '',
                            nst: data.nst || 0,
                            original_id: data.id || ''
                        });
                    }
                });
                
                console.log(`üéØ Filtered to ${results.length} results in magnitude range ${minMag}-${maxMag}`);
                
                // 3. Cache the results
                window.earthquakeCache.magnitudeRange.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });
                console.log(`üíæ Results cached with key: ${cacheKey}`);
                
                const executionTime = performance.now() - startTime;
                
                // Log fresh performance
                await logEarthquakePerformance('magnitude_range', executionTime, results.length, {
                    min_magnitude: minMag,
                    max_magnitude: maxMag,
                    cache_hit: false,
                    firebase_reads: snapshot.size
                });
                
                window.currentResults = results;
                window.currentPage = 1;
                displayResults();
                return results;
                
            } catch (error) {
                console.error('‚ùå Magnitude range search error:', error);
                alert('Magnitude search failed: ' + error.message);
                return [];
            }
        };

        // Network-Based Search
        window.searchByNetwork = async function(networkCode) {
            const startTime = performance.now();
            const cacheKey = networkCode.toLowerCase();
            
            // Check cache first
            if (window.earthquakeCache.networkFilters.has(cacheKey)) {
                const cacheEntry = window.earthquakeCache.networkFilters.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached network search results');
                    const executionTime = performance.now() - startTime;
                    
                    window.currentResults = cacheEntry.results;
                    window.currentPage = 1;
                    displayResults();
                    
                    await logEarthquakePerformance('network_search_cached', executionTime, cacheEntry.results.length, {
                        network_code: networkCode,
                        cache_hit: true
                    });
                    return cacheEntry.results;
                }
            }
            
            try {
                console.log(`üîç Searching for network ${networkCode} from Firebase`);
                const q = query(
                    collection(db, window.COLLECTION_NAME),
                    where('net', '==', networkCode),
                    limit(1000)
                );
                const snapshot = await getDocs(q);
                
                const results = [];
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    results.push({
                        id: docSnap.id,
                        time: data.time,
                        lat: parseFloat(data.lat) || 0,
                        long: parseFloat(data.long) || 0,
                        mag: parseFloat(data.mag) || 0,
                        net: data.net || '',
                        nst: data.nst || 0,
                        original_id: data.id || ''
                    });
                });
                
                // Cache the results
                window.earthquakeCache.networkFilters.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });
                
                const executionTime = performance.now() - startTime;
                
                await logEarthquakePerformance('network_search', executionTime, results.length, {
                    network_code: networkCode,
                    cache_hit: false,
                    firebase_reads: snapshot.size
                });
                
                window.currentResults = results;
                window.currentPage = 1;
                displayResults();
                return results;
                
            } catch (error) {
                console.error('Network search error:', error);
                alert('Network search failed: ' + error.message);
                return [];
            }
        };

        // üíæ CACHE MANAGEMENT FUNCTIONS

        // View earthquake cache status
        window.showEarthquakeCacheStatus = function() {
            const totalCached = 
                window.earthquakeCache.magnitudeRange.size +
                window.earthquakeCache.magnitudeGreater.size +
                window.earthquakeCache.locationSearch.size +
                window.earthquakeCache.timeFilters.size +
                window.earthquakeCache.networkFilters.size +
                window.earthquakeCache.fieldSearches.size +
                window.earthquakeCache.rangeSearches.size;
            
            const cacheInfo = `üåç Earthquake Data Cache Status: ‚úÖ Active\n` +
                             `Cache Expiry: 5 minutes\n\n` +
                             `Cache Contents:\n` +
                             `- Magnitude Ranges: ${window.earthquakeCache.magnitudeRange.size} queries\n` +
                             `- Magnitude Greater: ${window.earthquakeCache.magnitudeGreater.size} queries\n` +
                             `- Location Searches: ${window.earthquakeCache.locationSearch.size} queries\n` +
                             `- Time Filters: ${window.earthquakeCache.timeFilters.size} queries\n` +
                             `- Network Filters: ${window.earthquakeCache.networkFilters.size} queries\n` +
                             `- Field Searches: ${window.earthquakeCache.fieldSearches.size} queries\n` +
                             `- Range Searches: ${window.earthquakeCache.rangeSearches.size} queries\n\n` +
                             `Total Cached Queries: ${totalCached}`;
            
            alert(cacheInfo);
        };

        // Clear earthquake cache
        window.clearEarthquakeCache = function() {
            window.earthquakeCache = {
                magnitudeRange: new Map(),
                magnitudeGreater: new Map(),
                locationSearch: new Map(),
                timeFilters: new Map(),
                networkFilters: new Map(),
                fieldSearches: new Map(),
                rangeSearches: new Map()
            };
            alert('üåç Earthquake data cache cleared!');
        };

        // üìä PERFORMANCE ANALYTICS FUNCTIONS

        // Export performance data
        window.exportEarthquakePerformanceData = async function() {
            try {
                console.log('üîç Fetching performance data...');
                const q = query(collection(db, "earthquake_performance_logs"), orderBy("timestamp", "desc"));
                const snapshot = await getDocs(q);
                
                // Convert to CSV format
                const headers = ["timestamp", "function_name", "execution_time_ms", "execution_time_s", "result_count", "cache_hit", "field", "network_code", "min_magnitude", "max_magnitude"];
                let csvContent = headers.join(",") + "\n";
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const row = [
                        data.timestamp.toDate().toISOString(),
                        data.function_name,
                        data.execution_time_ms.toFixed(3),
                        data.execution_time_s.toFixed(6),
                        data.result_count,
                        data.cache_hit || false,
                        data.field || 'n/a',
                        data.network_code || 'n/a',
                        data.min_magnitude || 'n/a',
                        data.max_magnitude || 'n/a'
                    ];
                    csvContent += row.join(",") + "\n";
                });
                
                // Download CSV file
                downloadFile(csvContent, `earthquake_performance_${new Date().toISOString().split('T')[0]}.csv`, 'text/csv');
                
            } catch (error) {
                alert("Export failed: " + error.message);
            }
        };

        // Quick access functions for common earthquake searches
        window.quickMagnitudeSearch = function() {
            const magnitude = prompt("Enter minimum magnitude (e.g., 5.0):");
            if (magnitude && !isNaN(parseFloat(magnitude))) {
                document.getElementById('rangeField').value = 'mag';
                document.getElementById('minValue').value = magnitude;
                document.getElementById('maxValue').value = '10';
                rangeSearch();
            }
        };

        window.quickNetworkSearch = function() {
            const network = prompt("Enter network code (e.g., us, ci, nc, ak):");
            if (network) {
                searchByNetwork(network);
            }
        };

        window.quickMagnitudeRangeSearch = function() {
            const range = prompt("Enter magnitude range (format: 5.0-7.0):");
            if (range && range.includes('-')) {
                const [min, max] = range.split('-').map(x => parseFloat(x.trim()));
                if (!isNaN(min) && !isNaN(max)) {
                    searchMagnitudeRange(min, max);
                }
            }
        };

        // Debug function to test cache
        window.testCache = function() {
            console.log("üß™ Testing cache system...");
            console.log("Cache object:", window.earthquakeCache);
            console.log("Is cache valid function:", typeof isCacheValid);
            
            // Test cache with dummy data
            const testKey = "test-5.0-7.0";
            const testData = {
                results: [{id: "test", mag: 6.0}],
                timestamp: Date.now()
            };
            
            window.earthquakeCache.magnitudeRange.set(testKey, testData);
            console.log("‚úÖ Test data added to cache");
            
            const retrieved = window.earthquakeCache.magnitudeRange.get(testKey);
            console.log("Retrieved from cache:", retrieved);
            
            const isValid = isCacheValid(retrieved);
            console.log("Is cache entry valid?", isValid);
            
            alert("Cache test completed - check console for details");
        };

        // Initialize page when loaded
        window.addEventListener('load', function() {
            if (firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
                initializePage();
            }
        });
    </script>
</body>
</html>