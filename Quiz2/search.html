<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earthquake Search & Analysis</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .search-section {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .search-form {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .search-form input, .search-form button, .search-form select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .search-form button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            border: none;
        }
        .search-form button:hover {
            background-color: #0056b3;
        }
        .quick-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .quick-link {
            background-color: #007bff;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            display: block;
            cursor: pointer;
            border: none;
        }
        .quick-link:hover {
            background-color: #0056b3;
            text-decoration: none;
            color: white;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            max-height: 500px;
            overflow-y: auto;
            display: none;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .pagination button:hover:not(:disabled) {
            background-color: #f8f9fa;
        }
        .pagination button:disabled {
            background-color: #e9ecef;
            cursor: not-allowed;
        }
        .pagination .active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .back-link {
            color: #007bff;
            text-decoration: none;
            font-size: 16px;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .form-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .form-row label {
            min-width: 100px;
        }
        .form-row input {
            flex: 1;
            min-width: 100px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Dashboard</a>
        
        <h1>üîç Earthquake Search & Analysis</h1>
        
        <div id="error" class="error"></div>
        
        <!-- Quick Analysis Links -->
        <div class="search-section">
            <h2>üìä Quick Analysis</h2>
            <div class="quick-links">
                <button onclick="quickMagnitudeRange(5.0, 10.0)" class="quick-link">
                    üåã Major Earthquakes (5.0+)
                </button>
                <button onclick="quickMagnitudeRange(4.0, 4.9)" class="quick-link">
                    ‚ö†Ô∏è Moderate Earthquakes (4.0-4.9)
                </button>
                <button onclick="analyzeTimePatterns()" class="quick-link">
                    üåô Day vs Night Analysis
                </button>
                <button onclick="analyzeWeekendPatterns()" class="quick-link">
                    üìÖ Weekend vs Weekday
                </button>
                <button onclick="analyzeEarlyMorning()" class="quick-link">
                    üåÖ Early Morning Pattern
                </button>
                <button onclick="findClusters()" class="quick-link">
                    üó∫Ô∏è Earthquake Clusters
                </button>
            </div>
        </div>
        
        <!-- Magnitude Search -->
        <div class="search-section">
            <h2>üî¢ Search by Magnitude</h2>
            <div class="search-form">
                <div class="form-row">
                    <label>Greater than:</label>
                    <input type="number" id="magGreater" step="0.1" min="0" max="10" value="5.0">
                    <button onclick="searchMagnitudeGreater()">Search</button>
                </div>
            </div>
            
            <div class="search-form">
                <div class="form-row">
                    <label>Range:</label>
                    <input type="number" id="magMin" step="0.1" min="0" max="10" value="2.0" placeholder="Min">
                    <input type="number" id="magMax" step="0.1" min="0" max="10" value="5.0" placeholder="Max">
                    <button onclick="searchMagnitudeRange()">Search Range</button>
                </div>
            </div>
        </div>
        
        <!-- Location Search -->
        <div class="search-section">
            <h2>üìç Search Near Location</h2>
            <div class="search-form">
                <div class="form-row">
                    <label>Latitude:</label>
                    <input type="number" id="searchLat" step="0.0001" placeholder="e.g., 35.6762" value="35.6762" min="-90" max="90">
                    <label>Longitude:</label>
                    <input type="number" id="searchLng" step="0.0001" placeholder="e.g., 139.6503" value="139.6503" min="-180" max="180">
                    <label>Radius (km):</label>
                    <input type="number" id="searchRadius" min="1" max="1000" value="100">
                    <button onclick="searchNearLocation()">Search</button>
                </div>
            </div>
        </div>
        
        <!-- Loading Area -->
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <div>Searching earthquake data...</div>
        </div>
        
        <!-- Results Area -->
        <div id="results" class="results">
            <h3>Results</h3>
            <div class="search-form">
                <label>Results per page:</label>
                <select id="resultsPerPage" onchange="changeResultsPerPage()">
                    <option value="10">10</option>
                    <option value="20" selected>20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
            <div id="resultsContent"></div>
            <div id="paginationControls" class="pagination" style="display: none;">
                <button id="prevPage" onclick="goToPage(currentPage - 1)">Previous</button>
                <span>Page <span id="currentPageSpan">1</span> of <span id="totalPagesSpan">1</span></span>
                <button id="nextPage" onclick="goToPage(currentPage + 1)">Next</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
        <!-- Performance Analytics Dashboard -->
    <div class="search-section">
        <h2>üìà Performance Analytics</h2>
        <div class="quick-links">
            <button onclick="exportPerformanceData()" class="quick-link">
                üìä Export Performance CSV
            </button>
            <button onclick="viewPerformanceStats()" class="quick-link">
                üìã View Performance Stats
            </button>
            <button onclick="clearPerformanceLogs()" class="quick-link" style="background-color: #dc3545;">
                üóëÔ∏è Clear Performance Logs
            </button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, getDocs, addDoc, query, where, orderBy, limit, deleteDoc, doc, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Firebase configuration - Updated with new project details
        const firebaseConfig = {
            apiKey: "AIzaSyDIZ3GOpAbRX1vc39WOgDpQiYe27HNEVuI",
            authDomain: "assignment3-30ac7.firebaseapp.com",
            projectId: "assignment3-30ac7",
            storageBucket: "assignment3-30ac7.firebasestorage.app",
            messagingSenderId: "372305109147",
            appId: "1:372305109147:web:b8ceab0059242441aee63e",
            measurementId: "G-3VPTP8B4Q2"
        };

        // Initialize Firebase
        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            showError('Firebase configuration needed. Please update the firebaseConfig object.');
        }

        // Make Firebase available globally
        window.db = db;
        window.firestore = { collection, getDocs, query, where, orderBy, limit };

        // Simple query-specific cache - stores only searched results
        window.searchCache = {
            magnitudeGreater: new Map(),     // Key: magnitude, Value: {results, timestamp}
            magnitudeRange: new Map(),       // Key: "min-max", Value: {results, timestamp}
            locationSearch: new Map(),       // Key: "lat,lon,radius", Value: {results, timestamp}
            timePatterns: new Map(),         // Key: pattern type, Value: {results, timestamp}
        };
        
        // Cache expiration time (5 minutes)
        const CACHE_EXPIRY_MS = 5 * 60 * 1000;

        // Helper function to check if cache entry is still valid
        function isCacheValid(cacheEntry) {
            return cacheEntry && (Date.now() - cacheEntry.timestamp) < CACHE_EXPIRY_MS;
        }

        // Essential utility functions - available immediately
        window.showError = function(message) {
            const errorDiv = document.getElementById('error');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => errorDiv.style.display = 'none', 10000);
            } else {
                console.error('Error:', message);
                alert('Error: ' + message);
            }
        };

        window.showLoading = function showLoading() {
            const loadingDiv = document.getElementById('loading');
            if (loadingDiv) loadingDiv.style.display = 'block';
        }

        window.hideLoading = function hideLoading() {
            const loadingDiv = document.getElementById('loading');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        window.showSuccess = function showSuccess(message) {
            const successDiv = document.getElementById('success');
            if (successDiv) {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
                setTimeout(() => successDiv.style.display = 'none', 5000);
            } else {
                console.log('Success:', message);
            }
        }

        // Add missing performance functions
        window.clearPerformanceLogs = async function() {
            try {
                showLoading();
                // This would clear performance logs - simplified for now
                hideLoading();
                showSuccess('Performance logs cleared (function simplified)');
            } catch (error) {
                hideLoading();
                showError("Failed to clear performance logs: " + error.message);
            }
        };

        window.exportPerformanceData = function() {
            showError('Export function not yet implemented');
        };

        // Utility: safe date formatting
        window.formatDate = function(date) {
            if (!date) return '';
            if (date.toDate) date = date.toDate();
            if (typeof date === 'string') date = new Date(date);
            return date.toISOString().split('T')[0];
        };

        // Magnitude range: query Firestore (first time) then cache for instant repeats
        window.searchMagnitudeRange = async function() {
            const minMag = parseFloat(document.getElementById('magMin').value);
            const maxMag = parseFloat(document.getElementById('magMax').value);
            if (isNaN(minMag) || isNaN(maxMag)) {
                showError('Please enter valid magnitude values.');
                return;
            }

            showLoading();
            try {
                const cacheKey = `${minMag}-${maxMag}`;
                if (window.searchCache.magnitudeRange.has(cacheKey)) {
                    const cacheEntry = window.searchCache.magnitudeRange.get(cacheKey);
                    if (isCacheValid(cacheEntry)) {
                        console.log(`üöÄ Using cached results for magnitude ${minMag}-${maxMag}`);
                        hideLoading();
                        displayResults({
                            status: 'success',
                            query: `Magnitude ${minMag}-${maxMag} (Cached)`,
                            count: cacheEntry.results.length,
                            earthquakes: cacheEntry.results
                        });
                        return;
                    }
                }

                // Query Firestore by magnitude stored as string; filter numerically client-side
                const q = query(
                    collection(db, 'earthquakes'),
                    where('magnitude', '>=', String(minMag)),
                    where('magnitude', '<=', String(maxMag)),
                    orderBy('magnitude'),
                    limit(1000)
                );
                const snapshot = await getDocs(q);
                const results = [];
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const mag = parseFloat(data.magnitude ?? data.mag);
                    if (!isNaN(mag) && mag >= minMag && mag <= maxMag) {
                        results.push({
                            id: docSnap.id,
                            time: data.time,
                            timeFormatted: formatDate(data.time),
                            latitude: parseFloat(data.latitude) || 0,
                            longitude: parseFloat(data.longitude) || 0,
                            magnitude: mag,
                            place: data.place || ''
                        });
                    }
                });
                console.log(`‚úÖ Found ${results.length} results using ${snapshot.size} Firebase reads`);

                window.searchCache.magnitudeRange.set(cacheKey, { results, timestamp: Date.now() });

                hideLoading();
                displayResults({
                    status: 'success',
                    query: `Magnitude ${minMag}-${maxMag}`,
                    count: results.length,
                    earthquakes: results
                });
            } catch (error) {
                hideLoading();
                console.error('Search error:', error);
                showError('Search failed: ' + error.message);
            }
        };

        // Initialize local cache - load all data once when first search is performed
        window.initializeCache = async function() {
            if (window.earthquakeCache && window.earthquakeCache.isLoaded) {
                console.log('üì¶ Cache already loaded');
                return true;
            }

            // Ask user before loading all data
            const userConfirm = confirm('üîÑ Load all earthquake data into cache?\n\nThis will download ~10,000 records for faster searches.\nThis action will use Firebase reads.\n\nAlternatively, you can search without cache (slower but uses fewer reads).');
            
            if (!userConfirm) {
                console.log('User cancelled cache loading');
                return false;
            }

            console.log('üöÄ Initializing earthquake data cache...');
            const startTime = performance.now();
            
            try {
                const q = query(collection(db, "earthquakes"));
                const snapshot = await getDocs(q);
                
                const allData = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    
                    // Normalize and structure the data for fast access
                    let mag = data.magnitude || data.mag;
                    if (typeof mag === 'string') {
                        mag = parseFloat(mag);
                    }
                    
                    const entry = {
                        id: doc.id,
                        time: data.time,
                        timeFormatted: formatDate(data.time),
                        latitude: parseFloat(data.latitude) || 0,
                        longitude: parseFloat(data.longitude) || 0,
                        magnitude: mag || 0,
                        place: data.place || "",
                        // Pre-compute useful date properties for faster analysis
                        dateObj: data.time?.toDate ? data.time.toDate() : (typeof data.time === 'string' ? new Date(data.time) : data.time),
                    };
                    
                    // Add computed time properties for fast filtering
                    if (entry.dateObj) {
                        entry.hour = entry.dateObj.getHours();
                        entry.dayOfWeek = entry.dateObj.getDay();
                        entry.isWeekend = entry.dayOfWeek === 0 || entry.dayOfWeek === 6;
                        entry.isNight = entry.hour >= 18 || entry.hour < 6;
                        entry.isEarlyMorning = entry.hour >= 0 && entry.hour < 6;
                    }
                    
                    allData.push(entry);
                });
                
                // Sort by magnitude for better performance in magnitude searches
                allData.sort((a, b) => b.magnitude - a.magnitude);
                
                const endTime = performance.now();
                const loadTime = endTime - startTime;
                
                // Update cache
                window.earthquakeCache = {
                    isLoaded: true,
                    allData: allData,
                    totalCount: allData.length,
                    loadTime: loadTime,
                    lastUpdated: new Date()
                };
                
                console.log(`‚úÖ Cache initialized: ${allData.length} earthquakes loaded in ${loadTime.toFixed(3)}ms`);
                console.log(`üß† Memory usage: ~${Math.round(JSON.stringify(allData).length / 1024 / 1024 * 100) / 100}MB`);
                
                // Log the cache initialization performance
                await logPerformance('cache_initialization', loadTime, allData.length, {
                    memory_usage_mb: Math.round(JSON.stringify(allData).length / 1024 / 1024 * 100) / 100
                });
                
                return true;
            } catch (error) {
                console.error('‚ùå Cache initialization failed:', error);
                showError('Failed to initialize data cache: ' + error.message);
                return false;
            }
        };

        // Helper function to generate cache keys
        function generateCacheKey(functionName, params) {
            return `${functionName}_${JSON.stringify(params)}`;
        }

        // Performance logging function
        window.logPerformance = async function(functionName, executionTime, resultCount = 0, additionalData = {}) {
            try {
                const performanceData = {
                    function_name: functionName,
                    execution_time_ms: executionTime,
                    execution_time_s: executionTime / 1000,
                    result_count: resultCount,
                    timestamp: new Date(),
                    browser: navigator.userAgent.substring(0, 100), // Truncate for storage
                    ...additionalData
                };
                
                await addDoc(collection(db, "performance_logs"), performanceData);
                console.log(`üìä Performance logged: ${functionName} - ${executionTime.toFixed(3)}ms`);
            } catch (error) {
                console.error("Failed to log performance:", error);
            }
        };

        // Pagination variables - make them global
        window.allResults = [];
        window.currentPage = 1;
        window.resultsPerPage = 20;
        window.totalPages = 1;
        window.currentResultsType = null;

        // Utility Functions (kept only one instance to avoid duplicates)

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Search Functions with Simple Query-Specific Caching
        window.searchMagnitudeGreater = async function() {
            const magnitude = parseFloat(document.getElementById("magGreater").value);
            if (isNaN(magnitude)) {
                showError("Please enter a valid magnitude value.");
                return;
            }

            const cacheKey = magnitude.toString();
            
            // Check cache first
            if (window.searchCache.magnitudeGreater.has(cacheKey)) {
                const cacheEntry = window.searchCache.magnitudeGreater.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log(`üöÄ Using cached results for magnitude > ${magnitude}`);
                    displayResults({
                        status: "success",
                        query: `Magnitude > ${magnitude} (Cached)`,
                        count: cacheEntry.results.length,
                        earthquakes: cacheEntry.results
                    });
                    return;
                }
            }

            showLoading();
            const startTime = performance.now();
            console.log(`üîç Querying Firebase for magnitude > ${magnitude}`);

            try {
                const q = query(
                    collection(db, 'earthquakes'),
                    where('magnitude', '>', String(magnitude)),
                    orderBy('magnitude'),
                    limit(1000)
                );
                const snapshot = await getDocs(q);
                const results = [];
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const mag = parseFloat(data.magnitude ?? data.mag);
                    if (!isNaN(mag) && mag > magnitude) {
                        results.push({
                            id: docSnap.id,
                            time: data.time,
                            timeFormatted: formatDate(data.time),
                            latitude: parseFloat(data.latitude) || 0,
                            longitude: parseFloat(data.longitude) || 0,
                            magnitude: mag,
                            place: data.place || ''
                        });
                    }
                });

                // Cache the results
                window.searchCache.magnitudeGreater.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });

                const executionTime = performance.now() - startTime;
                console.log(`‚úÖ Found ${results.length} results in ${executionTime.toFixed(3)}ms using ${snapshot.size} Firebase reads`);
                
                hideLoading();
                displayResults({
                    status: "success",
                    query: `Magnitude > ${magnitude}`,
                    count: results.length,
                    earthquakes: results
                });
                
            } catch (error) {
                hideLoading();
                console.error("Search error:", error);
                showError("Search failed: " + error.message);
            }
        };

        window.searchNearLocation = async function() {
            const searchLat = parseFloat(document.getElementById('searchLat').value);
            const searchLng = parseFloat(document.getElementById('searchLng').value);
            const radius = parseFloat(document.getElementById('searchRadius').value);
            if (isNaN(searchLat) || isNaN(searchLng) || isNaN(radius)) {
                showError('Please enter valid location values.');
                return;
            }

            const startTime = performance.now();
            const simpleKey = `${searchLat},${searchLng},${radius}`;
            // Cache check (simple key)
            if (window.searchCache.locationSearch.has(simpleKey)) {
                const cacheEntry = window.searchCache.locationSearch.get(simpleKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached location results');
                    displayResults({
                        status: 'success',
                        query: `Within ${radius}km of (${searchLat}, ${searchLng}) (Cached)`,
                        count: cacheEntry.results.length,
                        earthquakes: cacheEntry.results
                    });
                    return;
                }
            }

            showLoading();
            console.log(`üîç Searching location within ${radius}km of (${searchLat}, ${searchLng})`);

            try {
                const memoKey = generateCacheKey('location_search', { searchLat, searchLng, radius });
                if (window.searchCache.locationSearch.has(memoKey)) {
                    const entry = window.searchCache.locationSearch.get(memoKey);
                    if (isCacheValid(entry)) {
                        const endTime = performance.now();
                        const executionTime = endTime - startTime;
                        console.log(`‚ö° Cache hit! Results retrieved in ${executionTime.toFixed(3)}ms`);
                        hideLoading();
                        displayResults({
                            status: 'success',
                            query: `Within ${radius}km of (${searchLat}, ${searchLng}) (Cached)`,
                            count: entry.results.length,
                            earthquakes: entry.results.slice(0, 200)
                        });
                        await logPerformance('location_search_cached', executionTime, entry.results.length, {
                            search_latitude: searchLat,
                            search_longitude: searchLng,
                            search_radius_km: radius,
                            cache_hit: true
                        });
                        return;
                    }
                }

                // Compute bounding box in degrees
                const latDelta = radius / 111.0; // ~111 km per degree latitude
                const lonDelta = radius / (111.0 * Math.cos(searchLat * Math.PI / 180));
                const minLat = searchLat - latDelta;
                const maxLat = searchLat + latDelta;
                const minLng = searchLng - lonDelta;
                const maxLng = searchLng + lonDelta;

                // Try numeric latitude query first
                let snapshot;
                try {
                    const qNum = query(
                        collection(db, 'earthquakes'),
                        where('latitude', '>=', minLat),
                        where('latitude', '<=', maxLat),
                        orderBy('latitude'),
                        limit(2000)
                    );
                    snapshot = await getDocs(qNum);
                } catch (e) {
                    console.warn('Numeric latitude query failed, falling back to string comparison:', e.message);
                    const qStr = query(
                        collection(db, 'earthquakes'),
                        where('latitude', '>=', String(minLat)),
                        where('latitude', '<=', String(maxLat)),
                        orderBy('latitude'),
                        limit(2000)
                    );
                    snapshot = await getDocs(qStr);
                }

                const results = [];
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const lat = parseFloat(data.latitude);
                    const lng = parseFloat(data.longitude);
                    if (isNaN(lat) || isNaN(lng)) return;
                    // First filter by longitude bounding box
                    if (lng < minLng || lng > maxLng) return;
                    const dist = haversineDistance(searchLat, searchLng, lat, lng);
                    if (dist <= radius) {
                        results.push({
                            id: docSnap.id,
                            time: formatDate(data.time),
                            latitude: lat,
                            longitude: lng,
                            magnitude: parseFloat(data.magnitude ?? data.mag) || 0,
                            place: data.place || '',
                            distance_km: Math.round(dist * 100) / 100
                        });
                    }
                });

                // Sort by distance
                results.sort((a, b) => a.distance_km - b.distance_km);

                // Cache both keys for future use
                const cacheObj = { results, timestamp: Date.now() };
                window.searchCache.locationSearch.set(memoKey, cacheObj);
                window.searchCache.locationSearch.set(simpleKey, cacheObj);

                const endTime = performance.now();
                const executionTime = endTime - startTime;
                console.log(`‚úÖ Location search returned ${results.length} results in ${executionTime.toFixed(3)}ms using ${snapshot.size} Firebase reads`);

                await logPerformance('location_search_bounding_box', executionTime, results.length, {
                    search_latitude: searchLat,
                    search_longitude: searchLng,
                    search_radius_km: radius,
                    bounding_min_lat: minLat,
                    bounding_max_lat: maxLat,
                    bounding_min_lng: minLng,
                    bounding_max_lng: maxLng,
                    firebase_reads: snapshot.size
                });

                hideLoading();
                displayResults({
                    status: 'success',
                    query: `Within ${radius}km of (${searchLat}, ${searchLng})`,
                    count: results.length,
                    earthquakes: results.slice(0, 200)
                });
            } catch (error) {
                hideLoading();
                console.error('Location search error:', error);
                showError('Search failed: ' + error.message);
            }
        };

        // Quick search functions
        window.quickMagnitudeRange = async function(minMag, maxMag) {
            document.getElementById('magMin').value = minMag;
            document.getElementById('magMax').value = maxMag;
            await searchMagnitudeRange();
        };

        // Analysis Functions with Cache Optimization
        window.analyzeTimePatterns = async function() {
            // Ensure cache map exists
            if (!window.searchCache.timePatterns || typeof window.searchCache.timePatterns.has !== 'function') {
                window.searchCache.timePatterns = new Map();
            }
            const cacheKey = 'time_patterns_analysis';
            
            // Check cache first
            if (window.searchCache.timePatterns.has(cacheKey)) {
                const cacheEntry = window.searchCache.timePatterns.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached time patterns analysis');
                    displayResults(cacheEntry.results);
                    return;
                }
            }

            // Perform Firebase query for day/night analysis
            showLoading();
            const startTime = performance.now();
            console.log('üîç Analyzing time patterns from Firebase');
            
            try {
                // Query significant earthquakes (magnitude > 4.0)
                const q = query(
                    collection(db, "earthquakes"),
                    where("magnitude", ">", 4.0),
                    limit(1000) // Limit for performance
                );
                
                const snapshot = await getDocs(q);
                let dayCount = 0;
                let nightCount = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const dateObj = data.time?.toDate ? data.time.toDate() : new Date(data.time);
                    
                    if (dateObj) {
                        const hour = dateObj.getHours();
                        const isNight = hour >= 18 || hour < 6;
                        
                        if (isNight) {
                            nightCount++;
                        } else {
                            dayCount++;
                        }
                    }
                });

                const total = dayCount + nightCount;
                const nightPercentage = total > 0 ? (nightCount / total * 100) : 0;
                const dayPercentage = total > 0 ? (dayCount / total * 100) : 0;

                const results = {
                    status: 'success',
                    analysis: 'Large earthquakes (>4.0) - Day vs Night',
                    count: total,
                    day_count: dayCount,
                    night_count: nightCount,
                    day_percentage: dayPercentage.toFixed(1),
                    night_percentage: nightPercentage.toFixed(1),
                    pattern: nightCount > dayCount ? 'More earthquakes occur at night' : 'More earthquakes occur during day',
                    reads_used: snapshot.size
                };

                // Cache the results
                window.searchCache.timePatterns.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });

                const executionTime = performance.now() - startTime;
                console.log(`‚úÖ Time analysis completed in ${executionTime.toFixed(3)}ms using ${snapshot.size} Firebase reads`);
                
                hideLoading();
                displayResults(results);
                
            } catch (error) {
                hideLoading();
                console.error("Time analysis error:", error);
                showError("Time analysis failed: " + error.message);
            }
        };

        window.analyzeWeekendPatterns = async function() {
            // Ensure cache map exists
            if (!window.searchCache.timePatterns || typeof window.searchCache.timePatterns.has !== 'function') {
                window.searchCache.timePatterns = new Map();
            }
            const cacheKey = 'weekend_patterns_analysis';
            
            // Check cache first
            if (window.searchCache.timePatterns.has(cacheKey)) {
                const cacheEntry = window.searchCache.timePatterns.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached weekend patterns analysis');
                    displayResults(cacheEntry.results);
                    return;
                }
            }

            // Perform Firebase query for weekend analysis
            showLoading();
            const startTimeWeekend = performance.now();
            console.log('üîç Analyzing weekend patterns from Firebase');
            
            try {
                // Query significant earthquakes (magnitude > 4.0)
                const q = query(
                    collection(db, "earthquakes"),
                    where("magnitude", ">", 4.0),
                    limit(1000)
                );
                
                const snapshot = await getDocs(q);
                let weekendCount = 0;
                let weekdayCount = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const dateObj = data.time?.toDate ? data.time.toDate() : new Date(data.time);
                    
                    if (dateObj) {
                        const dayOfWeek = dateObj.getDay();
                        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                        
                        if (isWeekend) {
                            weekendCount++;
                        } else {
                            weekdayCount++;
                        }
                    }
                });

                const total = weekendCount + weekdayCount;
                const weekendPercentage = total > 0 ? (weekendCount / total * 100) : 0;
                const weekdayPercentage = total > 0 ? (weekdayCount / total * 100) : 0;

                const results = {
                    status: 'success',
                    analysis: 'Large earthquakes (>4.0) - Weekend vs Weekday',
                    count: total,
                    weekend_count: weekendCount,
                    weekday_count: weekdayCount,
                    weekend_percentage: weekendPercentage.toFixed(1),
                    weekday_percentage: weekdayPercentage.toFixed(1),
                    pattern: weekendCount > weekdayCount ? 'More earthquakes occur on weekends' : 'More earthquakes occur on weekdays',
                    reads_used: snapshot.size
                };

                // Cache the results
                window.searchCache.timePatterns.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });

                const executionTime = performance.now() - startTimeWeekend;
                console.log(`‚úÖ Weekend analysis completed in ${executionTime.toFixed(3)}ms using ${snapshot.size} Firebase reads`);
                
                hideLoading();
                displayResults(results);
                
            } catch (error) {
                hideLoading();
                console.error("Weekend analysis error:", error);
                showError("Weekend analysis failed: " + error.message);
            }
        };

        window.analyzeEarlyMorning = async function() {
            // Ensure cache map exists
            if (!window.searchCache.timePatterns || typeof window.searchCache.timePatterns.has !== 'function') {
                window.searchCache.timePatterns = new Map();
            }
            const cacheKey = 'early_morning_analysis';
            
            // Check cache first
            if (window.searchCache.timePatterns.has(cacheKey)) {
                const cacheEntry = window.searchCache.timePatterns.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached early morning analysis');
                    displayResults(cacheEntry.results);
                    return;
                }
            }

            // Perform Firebase query for early morning analysis
            showLoading();
            const startTimeEarly = performance.now();
            console.log('üîç Analyzing early morning patterns from Firebase');
            
            try {
                // Query significant earthquakes (magnitude > 4.0)
                const q = query(
                    collection(db, "earthquakes"),
                    where("magnitude", ">", 4.0),
                    limit(1000)
                );
                
                const snapshot = await getDocs(q);
                let earlyMorningCount = 0;
                let otherTimeCount = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const dateObj = data.time?.toDate ? data.time.toDate() : new Date(data.time);
                    
                    if (dateObj) {
                        const hour = dateObj.getHours();
                        const isEarlyMorning = hour >= 0 && hour < 6;
                        
                        if (isEarlyMorning) {
                            earlyMorningCount++;
                        } else {
                            otherTimeCount++;
                        }
                    }
                });

                const total = earlyMorningCount + otherTimeCount;
                const earlyMorningPercentage = total > 0 ? (earlyMorningCount / total * 100) : 0;

                const results = {
                    status: 'success',
                    analysis: 'Large earthquakes (>4.0) - Early Morning (12AM-6AM)',
                    count: total,
                    early_morning_count: earlyMorningCount,
                    other_time_count: otherTimeCount,
                    early_morning_percentage: earlyMorningPercentage.toFixed(1),
                    pattern: `${earlyMorningPercentage.toFixed(1)}% of large earthquakes occur in early morning hours`,
                    reads_used: snapshot.size
                };

                // Cache the results
                window.searchCache.timePatterns.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });

                const executionTime = performance.now() - startTimeEarly;
                console.log(`‚úÖ Early morning analysis completed in ${executionTime.toFixed(3)}ms using ${snapshot.size} Firebase reads`);
                
                hideLoading();
                displayResults(results);
                
            } catch (error) {
                hideLoading();
                console.error("Early morning analysis error:", error);
                showError("Early morning analysis failed: " + error.message);
            }
        };

        window.findClusters = async function() {
            // Ensure cache map exists
            if (!window.searchCache.timePatterns || typeof window.searchCache.timePatterns.has !== 'function') {
                window.searchCache.timePatterns = new Map();
            }
            const cacheKey = 'earthquake_clusters';
            
            // Check cache first
            if (window.searchCache.timePatterns.has(cacheKey)) {
                const cacheEntry = window.searchCache.timePatterns.get(cacheKey);
                if (isCacheValid(cacheEntry)) {
                    console.log('üöÄ Using cached earthquake clusters analysis');
                    displayResults(cacheEntry.results);
                    return;
                }
            }

            // Perform Firebase query for clustering analysis
            showLoading();
            const startTimeClusters = performance.now();
            console.log('üîç Finding earthquake clusters from Firebase');
            
            try {
                // Query significant earthquakes (magnitude > 5.0) for clustering
                const q = query(
                    collection(db, "earthquakes"),
                    where("magnitude", ">", 5.0),
                    limit(500)
                );
                
                const snapshot = await getDocs(q);
                const earthquakes = [];
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    earthquakes.push({
                        id: doc.id,
                        latitude: parseFloat(data.latitude) || 0,
                        longitude: parseFloat(data.longitude) || 0,
                        magnitude: data.magnitude || 0,
                        place: data.place || ""
                    });
                });

                // Simple clustering by geographic regions (this is a basic implementation)
                const regions = {
                    'California': earthquakes.filter(eq => eq.latitude >= 32 && eq.latitude <= 42 && eq.longitude >= -125 && eq.longitude <= -114),
                    'Alaska': earthquakes.filter(eq => eq.latitude >= 54 && eq.latitude <= 72 && eq.longitude >= -180 && eq.longitude <= -130),
                    'Pacific Ring': earthquakes.filter(eq => eq.latitude >= -45 && eq.latitude <= 45 && (eq.longitude <= -120 || eq.longitude >= 120)),
                    'Other': []
                };

                // Put remaining earthquakes in "Other"
                regions.Other = earthquakes.filter(eq => 
                    !regions.California.includes(eq) && 
                    !regions.Alaska.includes(eq) && 
                    !regions['Pacific Ring'].includes(eq)
                );

                const results = {
                    status: 'success',
                    analysis: 'Large earthquakes (>5.0) - Geographic Clusters',
                    count: earthquakes.length,
                    clusters: {
                        California: regions.California.length,
                        Alaska: regions.Alaska.length,
                        'Pacific Ring': regions['Pacific Ring'].length,
                        Other: regions.Other.length
                    },
                    earthquakes: earthquakes.slice(0, 100), // Show top 100 for display
                    reads_used: snapshot.size
                };

                // Cache the results
                window.searchCache.timePatterns.set(cacheKey, {
                    results: results,
                    timestamp: Date.now()
                });

                const executionTime = performance.now() - startTimeClusters;
                console.log(`‚úÖ Cluster analysis completed in ${executionTime.toFixed(3)}ms using ${snapshot.size} Firebase reads`);
                
                hideLoading();
                displayResults(results);
                
            } catch (error) {
                hideLoading();
                console.error("Cluster analysis error:", error);
                showError("Cluster analysis failed: " + error.message);
            }
        };

        // Display and Pagination Functions (single, correct implementation)
        function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('resultsContent');
            const paginationDiv = document.getElementById('paginationControls');
            
            if (data.status === 'success') {
                window.allResults = data;
                window.currentPage = 1;
                
                if (data.analysis) {
                    window.currentResultsType = 'analysis';
                    paginationDiv.style.display = 'none';
                } else if (data.earthquakes) {
                    window.currentResultsType = 'earthquakes';
                    window.totalPages = Math.ceil(data.earthquakes.length / window.resultsPerPage);
                    paginationDiv.style.display = window.totalPages > 1 ? 'flex' : 'none';
                    console.log(`Total results: ${data.earthquakes.length}, Results per page: ${window.resultsPerPage}, Total pages: ${window.totalPages}`);
                }
                
                renderCurrentPage();
            } else {
                contentDiv.innerHTML = `<strong>‚ùå Error:</strong> ${data.message}`;
                paginationDiv.style.display = 'none';
            }
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function renderCurrentPage() {
            const contentDiv = document.getElementById('resultsContent');
            const data = allResults;
            
            let html = `<strong>${data.query || 'Search Results'}</strong><br>`;
            html += `Found ${data.count} records<br><br>`;
            
            if (currentResultsType === 'analysis') {
                html += `<strong>Analysis:</strong> ${data.analysis}<br>`;
                
                // Handle custom HTML (for performance stats)
                if (data.custom_html) {
                    html += data.custom_html;
                } else if (data.day_count !== undefined && data.night_count !== undefined) {
                    html += `Total: ${data.total_large_quakes}<br>`;
                    html += `Day: ${data.day_count} (${data.day_percentage}%)<br>`;
                    html += `Night: ${data.night_count} (${data.night_percentage}%)<br>`;
                } else if (data.weekday_count !== undefined && data.weekend_count !== undefined) {
                    html += `Total: ${data.total_earthquakes}<br>`;
                    html += `Weekday: ${data.weekday_count} (${data.weekday_percentage}%)<br>`;
                    html += `Weekend: ${data.weekend_count} (${data.weekend_percentage}%)<br>`;
                } else if (data.early_morning_count !== undefined) {
                    html += `Total: ${data.total_earthquakes}<br>`;
                    html += `Early Morning (0-6 AM): ${data.early_morning_count} (${data.early_morning_percentage}%)<br>`;
                    html += `Morning (6-12 PM): ${data.morning_count}<br>`;
                    html += `Afternoon (12-6 PM): ${data.afternoon_count}<br>`;
                    html += `Evening (6 PM-12 AM): ${data.evening_count}<br>`;
                } else if (data.clusters) {
                    html += `<table><tr><th>Cluster Size</th><th>Center Location</th><th>Avg Magnitude</th><th>Sample Location</th></tr>`;
                    data.clusters.forEach(cluster => {
                        html += `<tr>
                            <td><strong>${cluster.count}</strong></td>
                            <td>${cluster.center_lat}, ${cluster.center_lon}</td>
                            <td>${cluster.avg_magnitude}</td>
                            <td>${cluster.sample_location}</td>
                        </tr>`;
                    });
                    html += '</table>';
                }
                
                html += `<br><strong>Conclusion:</strong> ${data.conclusion}<br>`;
            } else if (currentResultsType === 'earthquakes' && data.earthquakes) {
                const startIndex = (currentPage - 1) * resultsPerPage;
                const endIndex = Math.min(startIndex + resultsPerPage, data.earthquakes.length);
                const pageResults = data.earthquakes.slice(startIndex, endIndex);
                
                html += `<p><em>Showing ${startIndex + 1}-${endIndex} of ${data.earthquakes.length} results</em></p>`;
                
                html += '<table><tr><th>Date</th><th>Location</th><th>Magnitude</th><th>Place</th>';
                if (data.earthquakes[0] && data.earthquakes[0].distance_km !== undefined) {
                    html += '<th>Distance (km)</th>';
                }
                html += '</tr>';
                
                pageResults.forEach(record => {
                    html += `<tr>
                        <td>${record.time}</td>
                        <td>${record.latitude.toFixed(3)}, ${record.longitude.toFixed(3)}</td>
                        <td><strong>${record.magnitude}</strong></td>
                        <td>${record.place}</td>`;
                    if (record.distance_km !== undefined) {
                        html += `<td>${record.distance_km}</td>`;
                    }
                    html += '</tr>';
                });
                html += '</table>';
                
                updatePaginationControls();
            }
            
            contentDiv.innerHTML = html;
        }

        function updatePaginationControls() {
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');
            const currentPageSpan = document.getElementById('currentPageSpan');
            const totalPagesSpan = document.getElementById('totalPagesSpan');
            
            if (prevBtn) prevBtn.disabled = window.currentPage <= 1;
            if (nextBtn) nextBtn.disabled = window.currentPage >= window.totalPages;
            if (currentPageSpan) currentPageSpan.textContent = window.currentPage;
            if (totalPagesSpan) totalPagesSpan.textContent = window.totalPages;
            
            console.log(`Pagination: Page ${window.currentPage} of ${window.totalPages}`);
        }

        window.goToPage = function(page) {
            console.log(`goToPage called with page: ${page}, currentPage: ${window.currentPage}, totalPages: ${window.totalPages}`);
            if (page >= 1 && page <= window.totalPages && page !== window.currentPage) {
                window.currentPage = page;
                console.log(`Changing to page ${window.currentPage}`);
                renderCurrentPage();
            } else {
                console.log(`Invalid page navigation: ${page} (current: ${window.currentPage}, total: ${window.totalPages})`);
            }
        };

        window.changeResultsPerPage = function() {
            const select = document.getElementById('resultsPerPage');
            window.resultsPerPage = parseInt(select.value);
            
            if (window.currentResultsType === 'earthquakes' && window.allResults.earthquakes) {
                window.totalPages = Math.ceil(window.allResults.earthquakes.length / window.resultsPerPage);
                window.currentPage = 1;
                renderCurrentPage();
                
                const paginationDiv = document.getElementById('paginationControls');
                paginationDiv.style.display = window.totalPages > 1 ? 'flex' : 'none';
            }
        };

        // Format inputs for better UX
        const numberInputs = document.querySelectorAll('input[type="number"]');
        numberInputs.forEach(input => {
            input.addEventListener('input', function() {
                let value = parseFloat(this.value);
                if (!isNaN(value)) {
                    if (this.step === '0.1') {
                        this.value = Math.round(value * 10) / 10;
                    } else if (this.step === '0.0001') {
                        this.value = Math.round(value * 10000) / 10000;
                    }
                }
            });
        });

        // Performance Analytics Functions
        window.exportPerformanceData = async function() {
            try {
                showLoading();
                const q = query(collection(db, "performance_logs"), orderBy("timestamp", "desc"));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    hideLoading();
                    showError("No performance data found. Run some searches first!");
                    return;
                }
                
                // Convert to CSV format
                const headers = ["timestamp", "function_name", "execution_time_ms", "execution_time_s", "result_count", "browser"];
                let csvContent = headers.join(",") + "\\n";
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const row = [
                        data.timestamp.toDate().toISOString(),
                        data.function_name,
                        data.execution_time_ms.toFixed(3),
                        data.execution_time_s.toFixed(6),
                        data.result_count,
                        `"${data.browser || 'Unknown'}"`
                    ];
                    csvContent += row.join(",") + "\\n";
                });
                
                // Download CSV file
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `earthquake_search_performance_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                hideLoading();
                console.log(`üìä Exported ${snapshot.size} performance records to CSV`);
            } catch (error) {
                hideLoading();
                console.error("Export failed:", error);
                showError("Failed to export performance data: " + error.message);
            }
        };

        window.viewPerformanceStats = async function() {
            try {
                showLoading();
                const q = query(collection(db, "performance_logs"), orderBy("timestamp", "desc"));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    hideLoading();
                    showError("No performance data found. Run some searches first!");
                    return;
                }
                
                // Calculate statistics by function
                const stats = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const funcName = data.function_name;
                    
                    if (!stats[funcName]) {
                        stats[funcName] = {
                            count: 0,
                            times: [],
                            totalResults: 0
                        };
                    }
                    
                    stats[funcName].count++;
                    stats[funcName].times.push(data.execution_time_ms);
                    stats[funcName].totalResults += data.result_count || 0;
                });
                
                // Calculate averages and display
                let statsHtml = `
                    <h3>üìà Performance Statistics</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                        <tr style="background-color: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 8px;">Function</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Executions</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Avg Time (ms)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Min Time (ms)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Max Time (ms)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Total Results</th>
                        </tr>
                `;
                
                Object.entries(stats).forEach(([funcName, data]) => {
                    const avgTime = data.times.reduce((a, b) => a + b, 0) / data.times.length;
                    const minTime = Math.min(...data.times);
                    const maxTime = Math.max(...data.times);
                    
                    statsHtml += `
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">${funcName.replace(/_/g, ' ')}</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">${data.count}</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">${avgTime.toFixed(2)}</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">${minTime.toFixed(2)}</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">${maxTime.toFixed(2)}</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">${data.totalResults}</td>
                        </tr>
                    `;
                });
                
                statsHtml += `</table><p><strong>Total Performance Records:</strong> ${snapshot.size}</p>`;
                
                hideLoading();
                displayResults({
                    status: 'success',
                    analysis: 'Performance Statistics',
                    count: snapshot.size,
                    custom_html: statsHtml
                });
                
            } catch (error) {
                hideLoading();
                console.error("Stats failed:", error);
                showError("Failed to load performance stats: " + error.message);
            }
        };

        window.clearPerformanceLogs = async function() {
            if (!confirm("Are you sure you want to delete all performance logs? This cannot be undone.")) {
                return;
            }
            
            try {
                showLoading();
                const q = query(collection(db, "performance_logs"));
                const snapshot = await getDocs(q);
                
                const deletePromises = [];
                snapshot.forEach(docSnapshot => {
                    deletePromises.push(deleteDoc(doc(db, "performance_logs", docSnapshot.id)));
                });
                
                await Promise.all(deletePromises);
                
                hideLoading();
                console.log(`üóëÔ∏è Deleted ${snapshot.size} performance records`);
                alert(`Deleted ${snapshot.size} performance records`);
                
            } catch (error) {
                hideLoading();
                console.error("Clear failed:", error);
                showError("Failed to clear performance logs: " + error.message);
            }
        };

        // Auto-initialize cache when page loads - DISABLED to prevent excessive Firebase reads
        // document.addEventListener('DOMContentLoaded', async function() {
        //     console.log('üåü Page loaded, starting cache initialization...');
        //     await initializeCache();
        // });

        // Add cache status display
        window.showCacheStatus = function() {
            if (window.earthquakeCache.isLoaded) {
                alert(`Cache Status: ‚úÖ Loaded\n` +
                      `Total Records: ${window.earthquakeCache.totalCount}\n` +
                      `Load Time: ${window.earthquakeCache.loadTime.toFixed(3)}ms\n` +
                      `Last Updated: ${window.earthquakeCache.lastUpdated.toLocaleString()}\n` +
                      `Memory Usage: ~${Math.round(JSON.stringify(window.earthquakeCache.allData).length / 1024 / 1024 * 100) / 100}MB\n\n` +
                      `Memoization Cache:\n` +
                      `- Magnitude Greater: ${window.searchCache.magnitudeGreater.size} queries cached\n` +
                      `- Magnitude Range: ${window.searchCache.magnitudeRange.size} queries cached\n` +
                      `- Location Search: ${window.searchCache.locationSearch.size} queries cached\n` +
                      `- Time Patterns: ${window.searchCache.timePatterns ? 'Cached' : 'Not cached'}\n` +
                      `- Weekend Patterns: ${window.searchCache.weekendPatterns ? 'Cached' : 'Not cached'}`);
            } else {
                alert('Cache Status: ‚ùå Not loaded\nCache will be automatically loaded when you perform your first search.');
            }
        };

    </script>
    
    <!-- Cache Status Section -->
    <div class="search-section">
        <h2>üíæ Cache Management</h2>
        <div class="quick-links">
            <button onclick="showCacheStatus()" class="quick-link" style="background-color: #28a745;">
                üìä View Cache Status
            </button>
            <button onclick="initializeCache()" class="quick-link" style="background-color: #17a2b8;">
                üîÑ Reload Cache
            </button>
            <button onclick="window.searchCache = { magnitudeGreater: new Map(), magnitudeRange: new Map(), locationSearch: new Map(), timePatterns: new Map() }; alert('Search cache cleared!');" class="quick-link" style="background-color: #ffc107;">
                üßπ Clear Search Cache
            </button>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 14px; color: #666;">
            <em>üöÄ Lightning fast searches with local caching and memoization</em>
        </div>
    </div>

    <!-- Note: All JavaScript functions are already declared in the main script block above -->

</body>
</html>